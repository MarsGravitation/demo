/*
数组的定义

var 数组名 [初始容量]T

var arr1 [3]int
var arr2 [3]bool

Go 中，数组的容量和数组的类型都是数组的一部分，换句话说，即是两个数组都存放 bool 类型的数据，但是很可能因为它们的容量不同导致它们无法比较

var arr1 [3]bool
var arr3 [4]bool

数组的初始化

默认值

初始化

// 定义长度为 3 的 bool 数组
var arr1 [3]bool

// 定义长度为 3 的 bool 数组并初始化
arr1 = [3]bool{true, false, false}

// 根据初始化值，推断数组的长度
arr := [...]int {1, 2, 3, 4, 5, 6}

// 初始化方式 3
arr3 := [5]int {1, 2}

// 根据索引初始化
arr4 ：= [5]int{0:1, 3:2}

切片

数组的局限性
因为数组的长度是数组的一部分，所以下面的函数仅仅能计算长度为 3 的数组

切片是一个拥有相同类型元素的可变长的序列
相当于是对数组的一层封装，支持自动扩容
切片是引用类型，包含地址，长度，容量，用于快速的操作数据集合

切片的声明

var name []T

定义一个存放 int 类型数据的切片
切片的定义和数组的定义很想，但是它不在需要我们指定初始容量

var s []int
var a []stirng
var v []int

初始化

a = []string{"cxd"}
b = []int{1, 2, 3}

基于数组定义切片

左闭右开
s3 := arr1[0, 4]

s4 := arr1[:4]

// 从开始到最后
s5 := arr[:]

s6 := arr1[:len(arr1)]

切片可以再切片

arr1 := [...]int{1, 2, 3, 4, 5, 6, 7, 8}

s1 := arr1[1:4]
s2 := arr1[5:8]

make 函数构建切片

指定了长度，但是不指定默认值，Go 会为我们添加上默认值

// 第二个参数是可变参数，分别是 len 和 cap，如果写一个的话，默认这两个参数使用一个值
func make(t Type, size ...IntegerType) type
s1 := make([]int, 3 ,3)

s1 := make([]int, 3)
s2 := make([]int, 0, 4)

切片的本质

1. 把切片理解成一个窗口，他可以框住一块连续的内存，这快内存中只能存放相同类型的元素
2. 切片属于引用类型，所以彼此之间不能比较，只能和 nil 比较
3. 切片中真正的数据保存在底层的数组中

切片之间是不能之间比较的
因为切片时引用类型的，它们只能和 nil 比较，也就是判断它是否被分配了内存
如果我们想判断一个切片是否为空，我们可以使用 len(切片) == 0 来实现
如果这个切片为 nil，那么它的长度和容量都是 0
如果这个切片的长度，容量为 0，但是不一定为 nil


切片的赋值拷贝

切片之间的拷贝是浅拷贝，他们回共用一个底层数组，对一个切片的修改会彼此影响

s1 := make([]int, 3 ,3)
s2 := s1
s2[0] = 999
s1 [999, 0, 0]
s2 [999, 0, 0]

切片的遍历
s1 := make([]int, 3 ,3)
for i := 0; i < len(s1); i++ {
	fmt.Println(s1[i])
}

for i, v := range s1 {
	fmt.Println(i, v)
}

append 方法的妙用

使用内置函数 append(切片，追加内容)自动完成切片的扩容

切片会按照一定的扩容机制对数组进行扩容，此时，原来的切片指向的数组会被更换掉


使用 copy 函数进行赋值切片

s0 := []int{1, 2, 3}
// var s1 []int 这样声明一个变量，内存为 nil，不能进行拷贝
// 使用 make() 创建切片，注意算好 len，不然他不能接受全拷贝给它的值
// 新切片的 cap 也要算好，不够的话会报错，out of range
s1 := make([]int, len(s0))

// 这仅仅是简单的引用传递，实际上他们会共用一个底层的数组
s2 := s0

// 使用 copy 函数，会拷贝一份底层的数组给当前的切片食用
copy(s0, s1)

从切片中删除元素

Go 没有专门用来删除切片元素的方法，只能使用切片的特性去删除元素
s0:= []int{1,2,3,4,5,6,7,8,9}
// 删除 index = 2
s0 = append(s0[0:2], s0[:3])

var a = make([]int, 5, 10)
for i := 0; i < 10; i++ {
	// 在 a 的基础上继续追加，cap 不够了会自动扩容
	a = append(a, i)
}

指针
	& 取变量的地址
	* 取值
	
// 返回指针，用来给基本的数据类型分配内存
func new(Type) *Type

// 返回 Type，一般用来给 channel,map,slice 分配内存
func make(t Type, size ... IntegerType) Type

Go 中我们对于引用类型的变量在使用时不仅要声明它，而且还要为他分配内存空间，否则我们的值就没办法存储
基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值

更复杂的数据通常需要使用多个字节，这些数据一般使用引用类型保存。一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址，或者内存地址中第一个字所在的位置

对于值类型的声明，我们不需要为他分配内存空间，因为我们在声明的时候已经默认为他分配好了内存空间

而我们想分配内存空间，需要使用 new 和 make

make 只适用于 slice,map,chan 的内存分配和创建，

make 的返回值是 Type，而不是他们的指针，因为这三种类型本省就是引用类型，没必要返回他们的指针

map
map[keyType]ValueType

var m map[string]int

不初始化而直接使用 报出 panic，需要我们为其申请空间，再使用

var b map[stirng]int
b = make(map[string]int, 5)
b["age"] = 12

value, ok := b["age3"]
if !ok{
	fmt.Println("找不到key")
}else {
	fmt.Printf("value: %d",value)
}

删除元素

delete(m, "age")



*/