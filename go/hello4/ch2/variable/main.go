package variable

/*
2.3 变量

var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。

var 变量名字 类型 = 表达式

如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值
初始化该变量。数值类型变量对应的零值是 0，布尔类型变量对应的类型是 false，字符串类型对应的零值是
空字符串，接口或引用类型（包括 slice、指针、map1、chan 和函数）变量对应的零值是 nil。数组
或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在 Go 语言中不存在未初始化的变量。
这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的何玲行为。

var s string
fmt.Println(s) // ""

也可以在一个声明语句中同时声明一组变量，或用一组初始化声明并初始化一组变量。

var i, j, k int // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string

初始化表达式可以是字面量或任意的表达式。在宝级别声明的变量会在 main 入口函数执行前完成初始化，局部变量
将在声明语句被执行到的时候完成初始化。

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：

var f, err = os.Open(name) // os.Open returns a file and an error

2.3.4 简短变量声明

简短变量声明语句用于声明和初始化局部变量

简短变量声明被广泛用于大部分的局部变量的声明和初始化。
var 形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始化无关紧要的地方

简短变量声明语句也可以用来声明和初始化一组变量：

i, j := 0, 1

:= 是一个变量声明语句
= 是一个变量赋值操作

不要混淆多个变量的声明和元组的多重赋值

i, j = j, i // 交换 i 和 j 的值

简短变量声明语句也可以用函数的返回值来声明和初始化变量

f, err := os.Open(name)

简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明
对这些声明过的变量就只有赋值行为。

in, err := os.Open(infile) // 声明了 in err 变量
out, err := os.Create(outfile) // 声明了 out，对已声明的 err 进行了赋值操作

// 简短变量声明语句必须至少要声明一个新的变量
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
// 解决办法是第二个简短变量声明语句改用普通的多重赋值语句

2.3.2 指针

指针的数据类型是 *int，指针被称之为 指向 int 类型的指针。
如果指针名字为 p，可以说 p 指针指向变量 x

*p 对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值

x := 1
p := &x // p, of type *int, points to x
*p = 2 // 2

对于聚合类型每个成员 --- 比如结构体的每个字段，或者是数组的每个元素 --- 也是对应一个变量，
因此也可以被取地址

变量有是有被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受 & 取地址操作

任何类型的指针的零值都是 nil。如果 p 指向某个有效变量，那么 p != nil 为真

&x = &x

每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了一个新的别名。例如，*p 就是变量
v 的别名。

2.3.3 new 函数

另一个创建变量的方法是调用内建的 new 函数。表达式 new(T) 将创建一个 T 类型的匿名变量，初始化
为 T 类型的零值，然后返回变量的地址，返回的指针类型为 *T

p := new(int)

用 new 创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，
我们还可以在表达式中使用 new(T)。

new(int)
=>
var d int
return &d

每次调用 new 函数都是返回一个新的变量的地址

 */
func main() {

}
