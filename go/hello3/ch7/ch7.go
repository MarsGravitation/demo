package main

import (
	"fmt"
	"sync"
)

/*
7.1 多值赋值和短变量声明
Go 语言支持多值赋值，在函数或方法内部也支持短变量声明并赋值，同时 Go 语言依据类型
字面量的值能够自动进行类型推断

7.1.1 多值赋值
可以一次性声明多个变量，并可以在声明时赋值，而且可以省略类型

合法
// 相同类型的变量可以在末尾带上类型
var x, y int
var x, y int = 1, 2

// 如果不带类型，编译器可以直接进行类型推断
var x, y = 1, 2
var x, y = 1, "tata"

// 不同类型的变量声明和隐式初始化可以使用如下语法
var (
	x int
	y string
)

非法
// 多值赋值语句中每个变量后面不能都带上类型
var x int, y int = 1, 2
var x int, y string = 1, "tata"
var x int, y int
var x int, y string

多值赋值的两种格式
1. 右边是一个返回多值的表达式，可以是返回多值的函数调用，也可以是 range 对 map、
slice 等函数的操作，还可以是类型断言

// 函数调用
x, y = f()

// range 表达式
for k, v := range map {}

// type assertion
v, ok := i.(xxx)

2. 赋值的左边操作数和右边的单一返回值的表达式的个数一样，逐个从左向右依次对左边
的操作数赋值
x, y, z = a, b, c

多值赋值语义
1. 对左侧操作数中的表达式、索引值进行计算和确定，首先确定左侧的操作数的地址，然后
对右侧的赋值表达式进行计算，如果发现右侧的表达式计算引用了左侧的变量，则创建临时
变量进行值拷贝，最后完成计算
2. 从左到右的顺序依次赋值
 */

func test() {
	x := []int{1, 2, 3}
	i := 0
	i, x[i] = 1, 2 // set i = 1, x[2] = 2
	fmt.Println(i, x)

	x = []int{1, 2, 3}
	i = 0
	x[i], i = 2, 1 // set x[0] = 2, i = 1
	fmt.Println(i, x)

	x = []int{1, 2, 3}
	i = 0
	x[i], i = 2, x[i] // set tem = x[0], x[0] = 2, i = tmp ==> i == 1
	fmt.Println(i, x)

	x[0], x[0] = 1, 2 // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)
	fmt.Println(x[0])
}

/*
7.1.2 短变量的声明和赋值
短变量的声明和赋值是指在 Go 函数或类型方法内部使用 := 声明并初始化变量，支持多值
赋值，格式如下：
a := va
a, b := va, vb

短变量的声明和赋值的语法要约：
1. 使用 := 操作符，变量的定义和初始化同时完成
2. 变量名后不要跟任何类型名，Go 编译器完全靠右边的值进行推导
3. 支持多值短变量声明赋值
4. 只能在函数和类型方法的内部

只要有一个新变量就可以使用 := 进行赋值。也就是说，在多值短变量的声明和赋值时，至少
有一个变量是新创建的局部变量，其他的变量可以复用以前的变量，不是新创建的变量执行的
仅仅是赋值
 */
var n int

func foo() (int, error) {
	return 1, nil
}
/*
规则：
1. 如果想编译通过，则 a 和 b 中至少要有一个是新定义的局部变量。换句话说，在此语句
所在代码块中，不能同时预先声明 a、b 两个局部变量
2. 如果在赋值语句 a, b := va, vb 所在的代码块中已经存在一个局部变量 a，则赋值
语句 a, b := va. vb 不会创建新变量 a，而是直接使用 va 赋值给已经声明的局部变量
a，但是会创建新变量 b，并将 vb 赋值给 b
3. 如果在赋值语句 a, b := va, vb 所在的代码块中没有局部变量 a 和 b，但在全局命名
空间有变量 a 和 b，则该语句会创建新的局部变量 a 和 b 并使用 va、vb 初始化它们。
此时赋值语句所在的局部作用域类内，全局的 a 和 b 被屏蔽

赋值操作符 = 和 := 的区别
1. = 不会声明并创建新变量，而是在当前赋值语句所在的作用域由内向外逐层去搜寻变量，
如果没有搜索到相同变量名，则报编译错误
2. := 必须出现在函数或类型方法内部
3. := 至少要创建一个局部变量并初始化
 */

// 访问全局变量 n
func g() {
	println(n)
}

func test02() {
	// 此时函数作用域里面没有 n
	// 所以创建新的局部变量 n
	n, _ := foo()

	// 访问的是全局变量 n
	g() // 0

	// 访问的是函数作用域下的 n
	println(n) // 1
}

/*
range 复用临时变量

程序全部打印 9，原因有以下两点：
1. for range 下的迭代变量 i 的值是共用的
2. main 函数所在的 goroutine 和后续启动的 goroutine 存在竞争关系
 */
func test03() {
	wg := sync.WaitGroup{}

	si := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	for i := range si {
		wg.Add(1)
		go func() {
			println(i)
			wg.Done()
		}()
	}
	wg.Wait()
}

/*
7.3 defer 陷阱

 */

/*
7.4 切片困惑

7.4.1 数组
Go 的数组是由固定个相同类型元素的数据结构，底层采用连续的内存空间存放，数组一旦
声明后大小就不可改变了
注意：Go 中的数组是一种基本类型，数组的类型不仅包括其元素类型，也包括其大小，[2]
int 和 [5]int 是两个完全不同的数组类型

创建数组
1. 声明时通过字面量进行初始化
2. 直接声明，不显示地进行初始化

数组名无论作为函数实参，还是作为 struct 嵌入字段，或者数组之间的直接赋值，都是值拷贝

*/

func f1(a [3]int) {
	a[2] = 10
	fmt.Printf("%p, %v\n", &a, a)
}

func test04() {
	// 指定大小的显示初始化
	a := [3]int{1, 2, 3}

	// 通过 ... 由后面的元素个数推断数组大小
	b := [...]int{1, 2, 3}

	// 指定大小，并通过索引值初始化，未显示初始化的元素被置为零值
	c := [3]int{1: 1, 2: 3}

	// 指定大小但不显示初始化，数组元素全被置为零值
	var d [3]int

	fmt.Println(len(a), a)
	fmt.Println(len(b), b)
	fmt.Println(len(c), c)
	fmt.Println(len(d), d)

	e := [3]int{1, 2, 3}
	// 直接赋值时值拷贝
	f := e

	// 修改 a 元素值并不影响 b
	e[2] = 4

	fmt.Printf("%p,%v\n", &e, e) // Oxc420012220 , (1 2 4]
	fmt.Printf("%p,%v\n", &f, f) // Oxc420012240 , (1 2 3]

	// 数组作为函数参数仍然是值拷贝
	f1(e) // Oxc4200122c0 , (1 2 10]

	g := struct {
		s [3]int
	}{
		s: e,
	}

	// 结构是值拷贝，内部的数组也是值拷贝
	h := g

	// 修改 g 中的元素并不影响 e
	g.s[2] = 30

	// 修改 h 中的数组元素值并不影响 d
	h.s[2] = 20

	fmt.Printf("%p,%v\n", &a, a) // Oxc420012220 , [1 2 4]
	fmt.Printf("%p,%v\n", &g, g) // 0xc420012300 , { [1 2 30]}
	fmt.Printf("%p,%v\n", &h, h) // Oxc420012320 , { [1 2 20]}
}

/*
7.4.2 切片
切片创建
1. 通过数组创建
array[b:e] 创建一个包括 e-b 个元素的切片，第一个元素是 array[b]，最后一个
元素是 array[e - 1]
2. make
通过内置的 make 函数创建，make([]T, len, cap) 中的 T 是切片元素类型，len
是长度，cap 是底层数组的容量，cap 是可选参数
3. 直接声明
可以直接声明一个切片，也可以在声明切片的过程中使用字面量进行初始化，直接声明但不进行
初始化的切片值为 nil
var a []int // a is nil
var a []int = []int{1, 2, 3, 4}

type slice struct {
	array unsafe.Pointer
	len int
	cap int
}
当 len 增长超过 cap 时，会申请一个更大容量的底层数组，并将数据从老数组复制到
新申请的数组中

nil 切片和空切片

make([]int, 0) 的切片指针有分配
Pointer=Array

var a []int 后者的内置指针为 0
Pointer=nil
 */
func test05() {
	var a []int

	b := make([]int, 0)

	if a == nil {
		fmt.Println("a is nil")
	} else {
		fmt.Println("a is not nil")
	}

	// 虽然 b 的底层数组大小为 0，但切片不是 nil
	if b == nil {
		fmt.Println("b is nil")
	} else {
		fmt.Println("b is not nil")
	}
}

/*
多个切片引用同一个底层数组引发的混乱
使用 append 扩展切片过程中可能修改底层数组的元素，间接地影响其他切片的值，也可能
发生数组复制重建

1. append 追加的元素没有超过底层数组的容量，append 操作会直接操作共享的底层数组，
如果其他切片有引用数组被覆盖的元素，则会导致其他切片的值也隐式发生变化
2. append 追加的元素加上原来的元素如果超出底层数组的容量，append 操作会重新
申请新数组，并将原来数组复制到新数组

由于二义性，所以再使用切片的过程中应该尽量避免多个切面共享底层数组，可以使用 copy
进行显式复制
 */
func test06() {
	a := []int{0, 1, 2, 3, 4, 5, 6}
	b := a[0:4]

	// a, b 共享底层数组
	b = append(b, 10, 11, 12)

	// a, b 继续共享底层数组，修改 b 会影响共享的底层数组，间接影响 a
	fmt.Println(a)

	// len(b) = 7，此时需要重新分配数组，并将原来数组值复制到新数组
	b = append(b, 12, 14)

	// 此时 a 和 b 指向底层数组的指针已经不同了
}

/*
7.5.1 传值还是传引用

Go 只有一种参数传递规则 --- 值拷贝
1. 函数参数传递时使用的是值拷贝
2. 实例赋值给接口变量，接口对实例的引用是值拷贝

有时明明是值拷贝，结果缺修改了变量的内容，有两种情况：
1. 直接传递的是指针。指针传递同样是值拷贝，但指针和指针副本的值指向的地址是同一个
地方，所以能修改实参值
2. 参数是复合数据类型，这些复合数据类型内部有指针类型的元素，此时参数的值拷贝并不
影响指针的指向

chan, map, slice, interface 内部都是通过指针指向具体的数据，这些类型的变量在
作为函数参数传递时，实际上相当于指针的副本

type hchan struct {
	buf unsafe.Pointer
}

type hmap struct {
	buckets unsafe.Pointer
}

type SliceHeader struct {
	Data unitptr
}

type nonEmptyInterface struct {

}
 */
func test07() {

}

/*
函数名的意义
1. 类型信息，表明其数据类型是函数类型
2. 函数名代表函数的执行代码的起始位置
3. 可以通过函数名进行函数调用
 */
func test08() {

}

func main() {
	test06()
}
