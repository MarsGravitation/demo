package main

import "fmt"

/*
3.1 类型简介

3.1.1 命名类型和未命名类型

命名类型
类型可以通过标识符来表示，这种类型称为命名类型。Go 语言中的基本类型中有 20 个预声明
简单类型都是命名类型，Go 语言还有一种命名类型 --- 用户自定义类型。
未命名类型
一个类型由预声明类型、关键字和操作符组合而成，这个类型称为未命名类型。未命名类型又称为
类型字面量。array、slice、map、channel、pointer、function、struct、interface
都属于类型字面量，也都是未命名类型。
所以 *int, []int, [2]int, map[k]v 都是未命名类型
注意：前面所说的结构和接口是未命名类型，这里的接口和接口是没有使用 type 格式定义

总结：
	1. 未命名类型和类型字面量是等价的
	2. 20 个预声明类型都属于命名类型
	3. 自定义类型属于命名类型

	命名类型：预声明类型（int，bool）、自定义类型
	未命名类型：array、slice。。。

3.1.2 底层类型
	1. 预声明类型和类型字面量的底层类型是它们自身
	2. 自定义类型 type newType oldType 是逐层递归向下查找的，知道查到的是
预声明类型活类型字面量

3.1.3 类型相同和类型赋值
	类型相同
	1. 两个命名类型相同的条件是两个类型声明的语句完全相同
	2. 命名类型和未命名类型永远不相同
	3. 两个未命名类型相同的条件是它们的类型声明字面量的结构相同，并且内部元素的类型
相同
	4. 通过类型别名语句声明的两个类型相同

	类型赋值
	1. T1 和 T2 的类型相同 - 类型为 T1 的变量可以赋值给 T2 的变量
	2. T1 和 T2 具有相同的底层类型，并且 T1 和 T2 里面至少有一个是未命名类型
	3. T2 是接口类型，T1 是具体类型，T1 的方法集是 T2 的方法集的超集
	4. T1 和 T2 都是通道类型，他们拥有相同的元素类型，并且 T1 和 T2 中至少有一个是未命名类型
	5. a 的预声明标识符 nil，T2 是 pointer、function、slice、map、channel、interface

3.1.4 类型强制转换
	var a T = (T) (b), 使用括号将类型和要转换的变量或表达式的值括起来
	需要满足的条件：
	1. x 可以直接赋值给 T 类型的变量
	2. x 的类型和 T 具有相同的底层类型
	3. x 的类型和 T 都是未命名的指针类型，并且指针指向的类型具有相同的底层类型
	4. x 的类型和 T 的类型都是整型或者都是浮点型
	5. x 的类型和 T 都是复数类型
	6. x 是整数值或 []byte 类型的值，T 是 string
	7. x 是字符串，T 是 []byte 或 []rune

	注意：
	1. 数值类型和 string 类型之间的相互转换可能造成值部分丢失；其他的转换仅是类型的
	转换，不会造成值的改变。string 和数字之间的转换可使用标准库 strconv
	2. Go 语言没有语言机制支持指针和 integer 之间的直接转换，可使用标准库中的 unsafe
	包进行处理

3.2 类型方法

3.2.1 自定义类型
	type newType oldType
	newType 与 oldType 具有相同的底层类型，并且都继承了底层类型的操作集合（这里的操作
	不是方法，比如底层类型是 map，支持 range 迭代访问，则新类型也可以使用 range 迭代
	访问）。除此之外，newType 和 oldType 是两个完全不同的类型，newType 不会继承
	oldType 的方法。无论 oldType 是什么类型，使用 type 声明的新类型都是一种命名类型，
	也就是说，自定类型都是命名类型

	自定义 struct 类型
	struct xxx struct {} // 使用 type 自定义的结构类型属于命名类型
	struct{} // 结构字面量属于未命名类型
	var s = struct{}{} // struct{} 是非命名类型空结构

	struct 初始化
	1. 按字段顺序进行初始化，不推荐
	2. 指定字段名进行初始化，推荐
	3. 使用 new 创建内置函数，字段默认初始化为其类型的零值，返回值是指向结构的指针
	4. 一次初始化一个字段
	5. 使用构造函数进行初始化，推荐
	func New(text string) error {}

	匿名字段
	被嵌入的字段必须是命名类型或命名类型的指针
	匿名字段的字段名默认就是类型名，如果匿名字段是指针类型，则默认的字段名就是指针指向的类型名
	type File struct {
		*file
	}

	自定义接口类型

3.2.2 方法
	可以看作特殊类型的函数，其显式地将对象实例或指针作为函数的第一个参数，并且参数名可以
	自己指定，而不强制要求一定是 this 或 self。这个对象实例或指针称为方法的接受者

	// 类型方法接受者是值类型
	func (t TypeName) MethodName(ParamList) (ReturnList) {}
	// 类型方法接受者是指针
	func (t *TypeName) MethodName(ParamList) (ReturnList) {}

	类型方法本质上就是一个函数，没有使用隐式的指针，可以将类型方法改写为常规的函数
	func MethodName(t TypeName, ParamList) (ReturnList) {}

	特点：
	1. 可以为命名类型增加方法（除了接口），非命名类型不能自定义方法
	命名接口类型本身就是一个方法的签名集合，所以不能为其增加具体的实现方法
	2. 方法的定义必须和类型的定义在同一个包中
	3. 可见性和变量一样
	4. 使用 type 定义的自定义类型是一个新类型，新类型不能调用原有类型的方法，但是底层类型
	支持的运算可被新类型继承

3.3.1 一般调用
	TypeInstanceName.MethodName(ParamList)

3.3.2 方法值

3.3.3 方法表达式

3.3.4 方法集
	命名类型方法接受者有两种类型，一个是值类型，另一个是指针类型，这个和函数是一样
的，前者的形参是值类型，后者的形参是指针类型。无论接受者是什么类型，方法和参数的实
参传递都是值拷贝。如果接受者是值类型，则传递的是值的副本；如果接受者是指针类型，则
传递的是指针的副本。

	定义了一个新类型 Int，新类型的底层类型是 int，Int 虽然不能继承 int 的方法，但
底层类型支持的操作（算术运算和赋值运算）可以被上层类型继承。
	接受者是 Int 类型的方法集合：
	func (i Int) Print()
	func (a Int) Max(b Int) Int

	接受者是 *Int 类型的方法集合
	func (i *Int) Set(a Int)

	类型的方法集总结：
	1. T 类型的方法集是 S
	2. *T 类型的方法集是 S 和 *S
	在直接使用 类型实例 调用类型的方法时，无论值类型变量还是指针类型变量，都可以调用类型
的所有方法，原因是编译器在编译期间能够识别出这种调用关系，做了自动转换。

3.4.1 组合
	内嵌字段的初始化和访问
	struct 的字段访问使用点操作符 .，struct 额字段可以嵌套很多层，只要内圈的字段是唯一
的即可，不需要使用全路径进行访问
	z.a 等价于 z.Y.X.a

	内嵌字段的方法调用
	struct 类型方法调用也使用点操作符，不同嵌套层次的字段可以有相同的方法，外层变量调用
内嵌字段的方法时也可以像嵌套字段的访问一样使用简化模式。如果外层字段和内层字段有
相同的方法，则使用简化模式访问外层的方法会覆盖内层的方法。即在简写模式下，Go 编译器
优先从外向内逐层查找方法，同名方法中的外层的方法能够覆盖内层的方法

3.5 函数类型
	使用 func FunctionName() 语法格式定义的函数称为有名函数，这里所谓的有名是
指函数在定义时指定了函数名；与之对应的是匿名函数，所谓的匿名函数就是在定义时使用 func
语法格式，没有指定函数名。
	函数类型也分为两种，一种是函数字面量类型（未命名类型），另一种是函数命名类型

	函数字面量类型
	函数字面量类型的预防表达格式是 func(InputTypeList)OutputTypeList, 可以看出
有名函数和匿名函数的类型都是属于函数字面量类型，有名函数的定义相当于初始化一个
函数字面量类型后将其赋值给一个函数名变量；匿名函数的定义也是直接初始化一个函数
字面量类型，只是没有绑定到一个具体变量上。从 Go 类型系统的角度来看，有名函数和匿名
函数都是函数字面量类型的实例

	函数命名类型
	type NewFuncType FuncLiteral

	函数签名
	就是有名函数和匿名函数的字面量类型

	字面量类型是一种未命名类型，其不能定义自己的方法，所以必须显示地使用 type 声明
一个有名函数类型，然后为其添加方法。通常说的函数类型就是指有名函数类型，函数签名是指
函数的字面量类型

 */

// Person 使用 type 声明的是命名类型
type Person1 struct {
	name string
	age int
}

type Map2 map[string]string

// 只要底层类型是 slice、map 等支持 range 的类型字面量，新类型仍然可以使用 range 迭代
type iMap2 Map2

func test30() {
	// 使用 struct 字面量声明的是未命名类型
	a := struct {
		name string
		age int
	} {"cxd", 26}
	fmt.Println(a)
}

func (m Map2) Print() {

}

func test31() {
	mp := make(map[string]string, 10)
	mp["hi"] = "tata"

	// mp 和 ma 有相同的底层类型
	var ma Map2 = mp
	ma.Print()

	// im 和 ma 虽然有相同的底层类型 map[string]string, 但他们中没有一个是未命名类型
	// 不能赋值，如下语句不能通过编译
	// var im iMap = ma

	// mp 和 ma 具有相同的底层类型，但是二者中没有一个是字面量类型，不能直接赋值
	// 可以强制进行类型转换
	var im iMap2 = (iMap2)(ma)
	print(im)

	// Map 实现了 Print(),所以其可以赋值给接口类型变量
	var i interface{
		Print()
	} = ma
	i.Print()
}

func test32() {
	s := "hello, world!"
	var a []byte
	a = []byte(s)
	var b string
	b = string(a)
	var c []rune
	c = []rune(s)

	fmt.Print(b, c)
}


func (a Int) Max2(b Int) Int {
	if a >= b {
		return a
	} else {
		return b
	}
}

func (i *Int) Set2(a Int) {
	*i = a
}

func (i Int) Print2() {
	fmt.Printf("value=%d\n", i)
}

func test33() {
	var a Int = 10
	var b Int = 20

	c := a.Max(b)
	c.Print() // 50
	(&c).Print() // 内部被编译器转换为 c.Print()

	c.Set(20) // 内部被编译器转换为 (&a).Set(20)
}