package ch8

/*
8.1.2 工程结构

1. 环境变量

$GOROOT: Go 的安装根目录
$GOPATH: Go 工作目录
$GOBIN: 是带有 main 函数的源程序执行 go install 时生成的可执行程序安装目录，默认是
$GOPATH/bin

2. 工作目录
	$GOPATH 环境变量所指定的目录称为 Go 的工作目录，$GOPATH 可以配置为多个目录。
工作目录有相同的目录结构，内含三个子目录:
	$GOPATH/---|
				|----- src
				|----- pkg
				|----- bin
	src 是工程的源码所在目录，一般 src 下的第一层目录是工程根目录，工程根目录一般采用
公司的域名 + 工程名或用户名的格式，如：
	$GOPATH/src/github.com/github
	$GOPATH/src/github.com.golang
	工程根目录下才是工程各个项目的目录，项目目录下可以是其源代码文件和各种包的源码，
这是一种推荐的代码组织形式。
	$GOPATH/src/github.com/github/gh-ost
	使用 go get 下载第三方的包，默认会将包下载到 $GOPATH目录中

8.2 命名空间和作用域

8.2.1 命名空间
	命名空间在编程语言中常用来表示标识符的可见范围。编程语言借助命名空间来解决标识符
不能同名的问题，命名空间实际上相当于给标识符添加了标识前缀，使标识符变得全局唯一。另外，
命名空间使程序组织更加模块化，降低了程序内部的耦合性。
	一个标识符可在多个命名空间中定义，它在不同命名空间的含义是互不相干的。在一个
新的命名空间中可以定义任意的标识符，他们不会与位于其他命名空间上的同名标识符发生冲突，
当然自定义标识符尽量不要使用语言自身的关键字，这些标识符具有全局作用域。
	Go 语言继承了命名空间的概念，采用包来组织代码，包名构成 Go 命名空间的一部分，不
同的包就是一个独立的命名空间。
	Go 语言除了宝级别显式地命名空间，还有隐式的命名空间。函数、方法，以及代码块，代码
块可以嵌套代码块，每一个代码块都构成一个隐式的命名空间。
	不同命名空间可以声明相同的标识符，所以不同的隐式的命名空间同样允许声明相同的标
识符（包括变量），这里就由变量覆盖的问题。

8.2.2 作用域
	在高级语言编程中，作用域是指名字与实体（可以理解为特定内存地址）的绑定保持有效的
那部分程序逻辑区间。Go 语言是静态作用域的语言。所谓静态作用域就是变量的作用域不依赖
程序执行时的因素，变量作用域在编译期就能确定。

	全局作用域
	在任何地方都可以访问的标识符，称其具有全局作用域。在 Go 语言中，全局作用域有两
类：
	1. Go 语言内置的预声明标识符，它们具有全局作用域，在任意命名空间内都可见。
	2. Go 语言包内以大写字母开头的标识符

	包内作用域
	在 Go 语言包内定义的以小写字母开头的标识符，它们在本报可见，在其他包都是不可见的

	隐式作用域
	每个代码块内定义的变量称为局部变量，这些局部变量只在当前代码块内可见，其 作用域属于
当前代码块的隐式作用域。

8.2.3 变量覆盖
	Go 编译器解析变量名到引用实体采用的是从里到外的搜索模式，里层的局部变量能够覆盖外层变量

8.3 包的基本概念
	Go 语言是使用包来组织源代码的，并实现命名空间的管理。任何源代码文件必须属于某个
包。源码文件的第一行有效代码必须是 package packageName 语句，通过该语句声明自己
所在的包。

8.3.1 基本概念
	Go 语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称。包可以
定义在很深的目录中，包的定义是不包括目录路径的，但是包的以引用一般是全路径的。如：
	$GOPATH/src/a/b/c
	package c
	导包：a/b/c

	包的习惯用法：
	包名一般是小写的，使用一个简短的包名
	包名一般要和所在的目录同名
	包一般放到公司的域名目录下，这样能够保证包名的唯一性

8.3.2 包引用
	标准包的源码位于 $GOPTAH/src 下面，标准包可以直接引用。自定义的包和第三方包的源
码必须放到 $GOPATH/src 目录下才能被引用
	包引用路径
	1. 全路径引用
	import "lab/test" --- $GOPATH/src/lab/test
	2. 相对路径引用
	import "../a"

	包引用格式
	1. 标准引用方式
	import "fmt"
	2. 别名引用方式
	import F "fmt"
	3. 省略方式
	import . "fmt"
	相当于把包 fmt 的命名空间直接合并到当前程序的命名空间中，使用 fmt 包内可导出
元素可以不用前缀 fmt，直接引用
	4. 仅执行包初始化 init 函数
	使用标准格式引用包，但是代码中却没有使用包，编译器会报错。import _ packageName
仅执行包的初始化函数

	注意：
	1. 一个包可以有多个 init 函数，包加载会执行全部的 init 函数，但并不能保证执行顺序，
所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。
	2. 包不能出现环形引用
	3. 包的重复引用是允许的

8.3.3 包加载
	在执行 main.main 之前，Go 引导程序会先对整个程序包进行初始化。
	1. 包初始化程序从 main 函数引用的包开始，逐级查找包的引用，知道找到没有引用其他的包，
最终生成一个包引用的有向无环图。
	2. Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化
	3. 先初始化常量，然后是全局变量，最后执行包的 init 函数


 */
